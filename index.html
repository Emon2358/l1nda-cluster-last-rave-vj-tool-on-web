<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WIKI FEEDBACK STREAM</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
        }
        canvas {
            display: block;
            /* 画面の端が気にならないように少し拡大 */
            transform: scale(1.05);
        }
        /* ロード表示 */
        #loader {
            position: fixed; bottom: 20px; right: 20px;
            color: rgba(255, 255, 255, 0.5);
            font-family: monospace; font-size: 1rem;
            display: none; z-index: 100;
            mix-blend-mode: difference;
        }
    </style>
</head>
<body>

    <div id="loader">LOADING NEW DATA...</div>
    <canvas id="mainCanvas"></canvas>

<script>
    const canvas = document.getElementById('mainCanvas');
    const ctx = canvas.getContext('2d', { willReadFrequently: true });
    const loader = document.getElementById('loader');

    // --- 設定 ---
    const API_ENDPOINT = "https://ja.wikipedia.org/w/api.php";
    const AUTO_JUMP_INTERVAL = 15000; // 15秒ごとに新しい記事へ
    const SCROLL_SPEED = 8; // 横スクロール速度

    // --- 状態管理 ---
    let article = {
        title: "",
        text: "",
        img: null,
        ready: false
    };
    
    let frame = 0;
    let scrollX = 0;
    let contentWidth = 0;

    // 初期化
    resize();
    window.addEventListener('resize', resize);
    // 最初の記事取得
    fetchRandomWiki();
    // 定期的な記事更新タイマー
    setInterval(fetchRandomWiki, AUTO_JUMP_INTERVAL);
    
    requestAnimationFrame(renderLoop);

    function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    }

    // --- Wikipedia API (ランダム取得のみ) ---
    async function fetchRandomWiki() {
        loader.style.display = 'block';
        
        const params = new URLSearchParams({
            origin: '*',
            action: 'query',
            format: 'json',
            generator: 'random',
            grnnamespace: 0,
            grnlimit: 1,
            prop: 'extracts|pageimages',
            piprop: 'original',
            explaintext: 1,
            exintro: 1,
        });

        try {
            const res = await fetch(`${API_ENDPOINT}?${params}`);
            const data = await res.json();
            
            if (!data.query || !data.query.pages) throw new Error("No data");
            const pageId = Object.keys(data.query.pages)[0];
            const page = data.query.pages[pageId];
            
            // 新しいデータを準備
            const newArticle = {
                title: page.title.toUpperCase(),
                // 長すぎるテキストはカット
                text: (page.extract || "").substring(0, 500).replace(/\s+/g, ' '),
                img: null,
                ready: false
            };
            
            // 画像読み込み処理
            if (page.original) {
                const img = new Image();
                img.crossOrigin = "Anonymous";
                img.onload = () => {
                    newArticle.img = img;
                    // 画像読み込み完了後にデータを差し替え＆位置リセット
                    updateArticle(newArticle);
                };
                img.onerror = () => {
                     // 画像失敗時もデータは差し替える
                    updateArticle(newArticle);
                };
                img.src = page.original.source;
            } else {
                // 画像なしの場合
                updateArticle(newArticle);
            }

        } catch (e) {
            console.error(e);
            loader.style.display = 'none';
        }
    }

    function updateArticle(newData) {
        article = newData;
        article.ready = true;
        // スクロール位置を画面右外へリセット
        scrollX = canvas.width + 100;
        loader.style.display = 'none';
    }

    // --- メイン描画ループ ---
    function renderLoop() {
        requestAnimationFrame(renderLoop);
        frame++;

        const w = canvas.width;
        const h = canvas.height;
        const cx = w / 2;
        const cy = h / 2;

        // =========================================
        // 1. 強烈なフィードバック処理 (画面をクリアしない)
        // =========================================
        ctx.save();
        
        // 中心基準で変形させる
        ctx.translate(cx, cy);
        
        // 拡大（ズーム効果）: 1.01〜1.03倍でジワジワ広がる
        const zoom = 1.015 + Math.sin(frame * 0.01) * 0.005;
        ctx.scale(zoom, zoom);
        
        // 回転（渦巻き効果）: ゆっくり回転し続ける
        ctx.rotate(0.005 * Math.sin(frame * 0.05));
        
        ctx.translate(-cx, -cy);
        
        // 前のフレームを少し暗くして描画（残像の減衰）
        // globalAlphaが1に近いほど残像が長く残る
        ctx.globalAlpha = 0.92;
        // 合成モードを工夫してサイケデリックな色にする
        // 'lighter'や'screen'だと光り輝き、'difference'だと色が反転し続ける
        ctx.globalCompositeOperation = (frame % 200 < 100) ? 'lighter' : 'difference';
        
        ctx.drawImage(canvas, 0, 0);
        ctx.restore();

        // リセット
        ctx.globalAlpha = 1.0;
        ctx.globalCompositeOperation = 'source-over';

        // ごく薄く黒を重ねて、無限発散を防ぐ（これがないと真っ白/真っ黒になる）
        ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
        ctx.fillRect(0, 0, w, h);


        // =========================================
        // 2. コンテンツのスクロール描画
        // =========================================
        if (!article.ready) return;

        // スクロール位置更新
        scrollX -= SCROLL_SPEED;

        let currentX = scrollX;
        const centerY = h / 2;
        const titleSize = h * 0.15; // タイトル文字サイズ
        const textSize = h * 0.05;  // 本文文字サイズ

        ctx.fillStyle = '#fff';
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 8;
        ctx.textBaseline = 'middle';

        // --- 画像描画 ---
        if (article.img) {
            // アスペクト比を維持して高さを画面の6割に
            const imgH = h * 0.6;
            const scale = imgH / article.img.height;
            const imgW = article.img.width * scale;
            
            // 画像の縁取り効果（光らせる）
            ctx.shadowColor = '#0ff';
            ctx.shadowBlur = 20;
            ctx.drawImage(article.img, currentX, centerY - imgH/2, imgW, imgH);
            ctx.shadowBlur = 0; // リセット

            currentX += imgW + 50; // 次の要素のためにXを進める
        }

        // --- タイトル描画 ---
        ctx.font = `900 ${titleSize}px Impact, sans-serif`;
        // 縁取りと塗り
        ctx.strokeText(article.title, currentX, centerY - titleSize/2);
        ctx.fillText(article.title, currentX, centerY - titleSize/2);
        
        const titleWidth = ctx.measureText(article.title).width;
        currentX += titleWidth + 50;

        // --- 本文描画 ---
        ctx.font = `bold ${textSize}px monospace`;
        ctx.lineWidth = 4;
        ctx.strokeText(article.text, currentX, centerY + titleSize/2);
        ctx.fillText(article.text, currentX, centerY + titleSize/2);

        const textWidth = ctx.measureText(article.text).width;
        currentX += textWidth;

        // 全体の幅を記録（ループ判定用だが今回は使い捨て）
        contentWidth = currentX - scrollX;

        // 画面外に出たらリセット（次の記事が来るまで待機状態のような位置へ）
        if (scrollX + contentWidth < -100) {
            // ループさせず、次のデータ更新を待つ形にする
            // (記事更新タイマーが次のデータを読み込んで位置をリセットしてくれる)
        }
    }
</script>
</body>
</html>
