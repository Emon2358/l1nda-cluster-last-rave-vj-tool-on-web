<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Motion Stacker VJ</title>
    <style>
        body {
            background-color: #000;
            color: #fff;
            font-family: 'Courier New', monospace;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
            padding: 20px;
            overflow: hidden;
        }

        /* コントロールパネル */
        .controls {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #444;
            padding: 15px;
            z-index: 100;
            width: 300px;
            border-radius: 8px;
        }

        h1 { margin: 0 0 10px 0; font-size: 1rem; color: #0ff; text-transform: uppercase; }

        label { display: block; margin-top: 10px; font-size: 0.8rem; color: #aaa; }
        input[type="range"] { width: 100%; margin-top: 5px; }
        input[type="file"] { margin-top: 5px; font-size: 0.8rem; width: 100%; }

        button {
            background: #0ff;
            color: #000;
            border: none;
            padding: 10px;
            width: 100%;
            margin-top: 15px;
            font-weight: bold;
            cursor: pointer;
        }
        button:hover { background: #fff; }

        /* キャンバス */
        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 0;
        }
        canvas {
            max-width: 100%;
            max-height: 100%;
            box-shadow: 0 0 50px rgba(0, 255, 255, 0.2);
        }

        /* 非表示要素 */
        .hidden-source { display: none; }
        
        #status { margin-top: 5px; color: #0f0; font-size: 0.8rem; }
    </style>
</head>
<body>

    <div class="controls">
        <h1>Motion Stacker</h1>
        
        <label>INPUT VIDEO (Local File)</label>
        <input type="file" id="fileInput" accept="video/*">
        
        <label>TRAIL FADE (残像の長さ)</label>
        <input type="range" id="fadeRange" min="1" max="50" value="5">
        
        <label>CHAOS COPIES (重なる量)</label>
        <input type="range" id="copyRange" min="1" max="20" value="8">

        <label>BOX SIZE (切り取る大きさ)</label>
        <input type="range" id="sizeRange" min="50" max="600" value="200">

        <button id="startBtn">▶ START VJ</button>
        <div id="status">Waiting...</div>
    </div>

    <div id="canvas-container">
        <canvas id="mainCanvas"></canvas>
    </div>

    <video id="sourceVideo" class="hidden-source" loop muted playsinline></video>
    <canvas id="motionCanvas" class="hidden-source"></canvas>

<script>
    const canvas = document.getElementById('mainCanvas');
    const ctx = canvas.getContext('2d', { alpha: false }); // 高速化のためalpha false
    
    const motionCanvas = document.getElementById('motionCanvas');
    const mCtx = motionCanvas.getContext('2d', { willReadFrequently: true });
    
    const video = document.getElementById('sourceVideo');
    const statusDiv = document.getElementById('status');
    
    // パラメータ
    const fadeRange = document.getElementById('fadeRange');
    const copyRange = document.getElementById('copyRange');
    const sizeRange = document.getElementById('sizeRange');

    let isPlaying = false;
    
    // 動体検知用変数
    let prevFrameData = null;
    const MOTION_SCALE = 0.1; // 計算負荷を下げるため1/10サイズで解析
    
    // ファイル読み込み
    document.getElementById('fileInput').addEventListener('change', (e) => {
        const file = e.target.files[0];
        if(file) {
            video.src = URL.createObjectURL(file);
            statusDiv.innerText = "Video Loaded. Press START.";
        }
    });

    // 開始
    document.getElementById('startBtn').addEventListener('click', async () => {
        if(isPlaying) return;
        if(!video.src) {
            alert("動画ファイルを選択してください");
            return;
        }

        try {
            await video.play();
            
            // キャンバスサイズ設定
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            
            // 解析用キャンバス（小さくする）
            motionCanvas.width = 160; // video.videoWidth * MOTION_SCALE;
            motionCanvas.height = 90; // video.videoHeight * MOTION_SCALE;
            
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            isPlaying = true;
            statusDiv.innerText = "Running...";
            renderLoop();
        } catch(e) {
            console.error(e);
            alert("再生エラー");
        }
    });

    // リサイズ対応
    window.addEventListener('resize', () => {
        if(isPlaying) {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }
    });

    function renderLoop() {
        if(!isPlaying) return;
        requestAnimationFrame(renderLoop);

        const w = canvas.width;
        const h = canvas.height;
        const mw = motionCanvas.width;
        const mh = motionCanvas.height;

        // 1. フェード処理（残像を作るため、完全に黒で消さず、薄い黒を重ねる）
        // range値: 1(遅い/長い) ～ 50(速い/短い)
        const fadeAlpha = fadeRange.value / 100;
        ctx.fillStyle = `rgba(0, 0, 0, ${fadeAlpha})`;
        ctx.fillRect(0, 0, w, h);

        // 2. 動体検知処理
        // 現在のフレームを小さいキャンバスに描画
        mCtx.drawImage(video, 0, 0, mw, mh);
        
        let currentFrameData;
        try {
            currentFrameData = mCtx.getImageData(0, 0, mw, mh);
        } catch(e) { return; }

        let maxDiff = 0;
        let maxX = 0;
        let maxY = 0;

        // グリッド単位で差分を計算 (ピクセル全走査は重いので飛ばし飛ばし見る)
        const grid = 4; // 4x4ピクセル単位
        const data = currentFrameData.data;
        const prev = prevFrameData ? prevFrameData.data : null;

        if (prev) {
            // 最も動きのあるブロックを探す
            // 簡易的にグリッドごとに合計差分を取る
            for (let y = 0; y < mh; y += grid) {
                for (let x = 0; x < mw; x += grid) {
                    let diffSum = 0;
                    
                    // グリッド内のピクセルを見る
                    const i = (y * mw + x) * 4;
                    // R, G, B の差分合計
                    diffSum += Math.abs(data[i] - prev[i]);
                    diffSum += Math.abs(data[i+1] - prev[i+1]);
                    diffSum += Math.abs(data[i+2] - prev[i+2]);

                    if (diffSum > maxDiff) {
                        maxDiff = diffSum;
                        maxX = x;
                        maxY = y;
                    }
                }
            }
        }

        // 現在のフレームを保存
        // 参照渡しにならないようコピーを作成
        prevFrameData = new ImageData(
            new Uint8ClampedArray(data),
            mw,
            mh
        );

        // 動きが閾値以下なら描画しない（静止時は真っ黒）
        if (maxDiff < 30) return;

        // 3. 座標変換（小さいキャンバス → 元動画の座標）
        const scaleX = video.videoWidth / mw;
        const scaleY = video.videoHeight / mh;
        
        const sourceCenterX = maxX * scaleX;
        const sourceCenterY = maxY * scaleY;
        
        // 切り出すサイズ
        const boxSize = parseInt(sizeRange.value);
        
        // ソース動画から切り出す座標 (はみ出し防止なし。黒になるだけなのでOK)
        const sx = sourceCenterX - boxSize / 2;
        const sy = sourceCenterY - boxSize / 2;

        // 4. カオス描画（重ねまくる）
        const copies = parseInt(copyRange.value);
        
        // キャンバスの中心
        const cx = w / 2;
        const cy = h / 2;

        ctx.save();
        ctx.translate(cx, cy); // 画面中央を基準にする

        // 指定回数ループして描画
        for (let i = 0; i < copies; i++) {
            ctx.save();
            
            // ランダムな角度
            const angle = Math.random() * Math.PI * 2;
            ctx.rotate(angle);
            
            // ランダムな距離（中心から少し散らす）
            const offset = (Math.random() - 0.5) * (boxSize * 0.5);
            
            // 合成モードを少し変えて光らせる（お好みで）
            ctx.globalCompositeOperation = 'lighter';

            // 切り取った動画を描画
            // drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight)
            ctx.drawImage(
                video, 
                sx, sy, boxSize, boxSize, // ソースの切り出し位置
                -boxSize/2 + offset, -boxSize/2, boxSize, boxSize // 描画位置（回転してるので中心基準）
            );
            
            ctx.restore();
        }

        ctx.restore();
    }
</script>
</body>
</html>
